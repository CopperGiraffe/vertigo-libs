<th:block th:fragment="page(title)">
	<vu:head title=${title} />
	<body>
		<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"> </script>
		<script src="https://cdn.jsdelivr.net/npm/quasar-framework@0.17.16/dist/umd/quasar.mat.umd.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/quasar-framework@0.17.16/dist/umd/i18n.fr.umd.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/vue-resource@1.5.1"></script>
		<span th:text="${title}" />
		<div id="page">
			<p th:text="${uiMessageStack.objectFieldErrors}" th:if="${uiMessageStack.hasErrors()}"></p>
			<vu:content/>
		</div>
		<vu:vue-data/>
		<script>
			Quasar.i18n.set(Quasar.i18n.fr)
			var data = {
					  vueData : vueData,
					  componentStates : componentStates,
					  ctxId : ctxId
				  };
			var demo = new Vue({
			  el: '#page',
			  data: data,
			  methods: {
				transformListForSelection: function (list, valueField, labelField) {
					return this.$data.vueData[list].map(function (object) {
						return { value: object[valueField], label: object[labelField]}
					});
				},
				request : function (params) {
					var pagination = params.pagination;
					var filter = params.filter;
					var oldPagination = componentStates[pagination.componentId].pagination;
					if (oldPagination.sortBy != pagination.sortBy ||  oldPagination.descending != pagination.descending ) {
						// it's a sort order call the server
						pagination.page = 1 //reset pagination
						this.$http.post(pagination.sortUrl, { sortFieldName : pagination.sortBy, sortDesc : pagination.descending, CTX: this.$data.ctxId}, { emulateJSON: true }).then( function (response ) {
							vueData[pagination.listKey] = response.body[pagination.listKey];
							this.$data.ctxId = response.body['CTX'];
						});
					}
						// otherwise it's pagination or filter : do it locally
						// nothing to do everything is done by the paginatedData function
					componentStates[pagination.componentId].pagination = pagination;
				},
				paginatedData: function (list, componentId) {
					var pagination = componentStates[componentId].pagination;
					if (pagination.rowsPerPage != 0) { // not all
						var firstRowIndex = (pagination.page - 1) * pagination.rowsPerPage;
						var lastRowIndex = pagination.page * pagination.rowsPerPage;
						return this.$data.vueData[list].slice(firstRowIndex, lastRowIndex);
					}
					return this.$data.vueData[list];
				},
				selectedFunction : function (object, field, item, keyboard) {
					this.$data.vueData[object][field] = item.value;
				},
				searchAutocomplete : function (list, valueField, labelField, url, terms, done) {
					this.$http.post(url, {terms: terms, list : list , valueField : valueField,labelField : labelField, CTX: this.$data.ctxId}, { emulateJSON: true }).then( function (response ) {
						var finalList =  response.body.map(function (object) {
							return { value: object[valueField].toString(), label: object[labelField].toString()}
						});
						done(finalList);
					}, 
					function (response) {
						this.$q.notify(response.status + ":" +response.statusText);
						done([]);
					});
					
				},
				formatDate : function (object, field, newValue, format) {
					this.$data.vueData[object][field] = Quasar.utils.date.formatDate(newValue, format);
				},
				parseDate : function (object, field, format) {
					var parts = this.$data.vueData[object][field].match(/(\d+)/g);
					var i=0;
					var fmt={};
					format.replace(/(YYYY|MM|DD)/g, function(part) { fmt[part] = i++; });
					return Quasar.utils.date.buildDate({year :parts[fmt['YYYY']], month :parts[fmt['MM']], date : parts[fmt['DD']]});
				}
			  }
			})
		</script>
		</div>
	</body>
</th:block>
