<html>
<body>
Gestion de la couche Modèle.
<br>Il s'agit du noyau de Dynamo.
<br>
<br>Contient notamment les structures transverses de Dynamo <b>DtObject</b> et <b>DtList</b>.
<br>Ces 2 notions utilisent les notions secondaires suivantes : <ul>
<li>Contraintes : <b>Constraint</b></li>
<li>Triggers : <b>Trigger</b></li>
</ul>
<br>
<br>
Tout DtField possède un (au moins, au plus)  DtDomain.
<br>Et tout DtDomain possède un (au moins, au plus) un KDataType et un Formatter.
<br><br>
Lorsque vous déclarez un champ comme Integer ou Integer(3) dans le KSP 
vous utilisez implicitement le Domaine DO_$INTEGER, créé une seule fois avec le formatter par défaut et sans aucune contrainte.
<br>La déclaration étant locale, la contrainte 3 est portée par le seul champ de la même façon que l'aspect non null s'il est précisé. 
<br><br>
Si vous déclarez un champ comme DO_MONTANT alors 
vous utilisez explicitement le Domaine DO_MONTANT.
<br>
Du coup tout est domaine dans les champs : je rappelle que le domaine représente un enrichissement des Types primitifs Dynamo (Integer par ex).
<br>Il faut préférer la  notion domaine aux types Dynamo.
<br><br>
<u>Exemple : </u>
<br>Long peut être utilisé comme un type identifiant (DO_IDENTIFIANT) ou comme une valeur monétaire. (DO_MONTANT)
<br>String(30) peut utilisé comme un libellé court (DO_LIBELLE) ou comme un identifiant (DO_IDENTIFIANT) ou ....
<br><br>
La notion de domaine ajoute du sens que les seuls types Dynamo sont incapables de porter.
<br>En dégangent ce sens vous ajoutez de la lisibilité à vos ksp et/ou  mpd (on parle de dictionnaire de données).

<br><br><br>
 
 
 
 <br><h1>Services</h1>

<br>Contient aussi la notion de <b>Service</b> et leur moteur d'exécution à savoir les <b>ServiceProvider</b>.
<br>
Un service est un consommable, à n'utiliser qu'une seule fois et ayant une durée de vie réduite.(A ce titre un service n'est pas serializable.)
<ol>
 <li>Vous récupérez un service tout propre via la ServiceRegistry.</li>
 <li>Vous settez les paramètres via la méthode setValue</li>
 <li>Vous exécutez le service</li>
 <li>Vous récupérez les données.</li>
</ol>

Et c'est <b>TOUT</b>, si vous utilisez xml2java : le code est généré tout seul. (Vous avez même le droit de le lire)

Du point de vue développeur les services possèdent donc trois méthodes suivantes 
<ul>
 <li>setValue</li>
 <li>execute</li> 
 <li>getValue</li>
</ul>

Le service aura auparavant été déclaré dans le ksp.
<br>Vous y aurez associé des paramètres d'entrée de sortie, un serviceProvider ainsi qu'une chaine textuelle de paramétrage.

<br>Le serviceProvider est le réel moteur d'exécution du service.
<br>Dynamo en propose qquns par défaut mais vous pouvez SI BESOIN uniquement écrire le votre.
<br><br>
ServiceProvider doit dire comment s'exécuter (Méthode execute à surcharger obligatoirement).
<br>
Pour s'exécuter vous pouvez accéder aux paramètres IN via la méthode getValue, ainsi qu'à la définition du service( getServiceDefinition).
<br>Quand vous exécutez vous settez les valeurs de sortie du service via la méthode setValue.
<br><br>

Vous pouvez aussi déléguer l'exécution à un autre ServiceProvider
<br>Comme ceci dans la méthode execute :
<br>            ServiceProvider spDelegate = new ServiceProviderDeLaMuerte();
<br>       //On délègue la gestion au délégué
<br>       this.delegateTo(spDelegate);
<br>       //puis on fait travailler le délégué
<br>       spDelegate.execute(conn);
<br>
Comme dans la vrai vie le ServiceProvider qui a délégué conserve ses données même si elles sont générées par un autre.
<br>On peut imaginer que le délégué délègue une partie du boulot à un sous délégué....
<br>On arrive alors à la chaine suivante 
<br>Service.execute  ::appel du moteur :: ServiceProvider :: délègue à :: ServiceProvider1 :: délègue à :: ServiceProvider2.
<br>Cest intéressant si vous souhaitez placer en frontal des ServiceProvider qui filtrent (Cache) ou qui postraitent des données.
<br>Votre délégué est dans ce cas le réel Service.
<br>Service.execute  :: appel du moteur :: ServiceProvider Cache : Si Cache ok on renvoie les données en cache
<br>Service.execute  :: appel du moteur :: ServiceProvider Cache : Si Cache pas ok on délègue au select :: ServiceProviderSelect

<br>Du point de vue développeur serviceProvider possède donc les méthodes suivantes
<ul>
 <li>setValue</li>
 <li>execute</li>
 <li>getServiceDefinition</li>
 <li>setValue</li>
 <li>delegateTo</li>
 <li>getValue</li>
</ul>

<br><h1>Formatters</h1>
Les Formatters ont été modifiés dans Dynamo.
<br>
Pour rappel, jusqu'à maintenant ils ne géraient que la partie affichage d'un type de données (ex : conversion des montants dans la devise de l'utilisateur à l'affichage), maintenant ils gèrent aussi l'aspect validation du format de saisie de ce type de données (ex : vérification que l'utilisateur n'a pas saisi des lettres dans un champ de type montant).
<br>
Pour résumer les modifications :
<br><ol>
<li>L'interface Formatter a été déplacée de Dynamo.model vers Dynamo.controller. Son contrat n'a pas changé.</li>
<li> 
Ajout de FormatterRegistry dans Dynamo.controller. Cette classe sert à déclarer les Formatters de l'application dans la méthode postInit() du ApplicationState.
C'est la même chose que pour les Renderer, si ce n'est que les noms d'enregistrement des Formatters doivent être préfixés par "FMT_".
<br/>
ex :<br/> 
getFormatterRegistry().register("FMT_MONTANT", new DemoMontantFormatter());
<br>
</li>
<li>Dans les tags, les Formatters sont déclarés via getFormatterName(), qui retourne le nom sous lequel a été enregistré le Formatter, et non plus getFormatter(), qui a disparu.
<br/>Par défaut la méthode retourne null quand il n' y a pas de Formatter spécifique.
</li>
<li>Il y a un exemple de Formatter de montant dans la démo Dynamo, qui utilise la devise déclarée en session.</li>
</ol>
<br>

<h1>Domain</h1>
Dorénavant tout DtField possède un (au moins, au plus)  DtDomain.
<br>Et tout DtDomain possède un (au moins, au plus) un KDataType et un Formatter.
<br>
Lorsque vous déclarez un champ comme Integer ou Integer(3) dans le KSP 
vous utilisez implicitement le Domaine DO_$INTEGER, créé une seule fois avec le formatter par défaut et sans aucune contrainte.
<br>La déclaration étant locale, la contrainte 3 est portée par le seul champ de la même façon que l'aspect non null s'il est précisé. 
<br>
Si vous déclarez un champ comme DO_MONTANT alors 
vous utilisez explicitement le Domaine DO_MONTANT.

<br>Du coup tout est domaine dans les champs : je rappelle que le domaine représente un enrichissement des Types primitifs Dynamo (Integer par ex).
<br>Il faut préférer la  notion domaine aux types Dynamo.

<br><u>Exemple : </u>
<br>Long peut être utilisé comme un type identifiant (DO_IDENTIFIANT) ou comme une valeur monétaire. (DO_MONTANT)
<br>String(30) peut utilisé comme un libellé court (DO_LIBELLE) ou comme un identifiant (DO_IDENTIFIANT) ou ....
<br>
La notion de domaine ajoute du sens que les seuls types Dynamo sont incapables de porter.
<br>En dégangent ce sens vous ajoutez de la lisibilité à vos ksp et/ou  mpd (on parle de dictionnaire de données).



</body>
</html>